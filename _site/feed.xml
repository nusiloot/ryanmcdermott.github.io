<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ryansworks</title>
    <description>Developer and Musician blogging about VR, Webdev, Machine Learning, and Startups
</description>
    <link>http://www.ryansworks.com/</link>
    <atom:link href="http://www.ryansworks.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 20 Aug 2015 03:28:11 +0000</pubDate>
    <lastBuildDate>Thu, 20 Aug 2015 03:28:11 +0000</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Sublime Text Workflow Patterns and Tricks</title>
        <description>&lt;div&gt;
  Editors are personal choices, just like a lifestyle, tradition or philosophy. As with those things, there are no right and wrong choices. There are only suggestions that may or may not be helpful to you. Pick what works for you and don’t listen to naysayers that make judgments based on what helps you the most. Having said that, here’s my list of development workflow patterns that I use with my editor of choice, Sublime Text 3:
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Use Vintageous.&lt;/strong&gt; It’s super helpful. It allows you to use Vim commands within Sublime. Serious Vim users won’t find everything there, but it employs the 80/20 of Vim nicely (80% of what I need is there from the 20% of Vim’s features) &lt;a href=&quot;https://github.com/guillermooo/Vintageous&quot;&gt;https://github.com/guillermooo/Vintageous&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use a large monitor.&lt;/strong&gt; For one it’s annoying to try to click through tabs and separate windows. Additionally, it’s been shown to increase productivity. &lt;a href=&quot;http://gbr.pepperdine.edu/2010/08/three-ways-larger-monitors-can-improve-productivity/&quot;&gt;http://gbr.pepperdine.edu/2010/08/three-ways-larger-monitors-can-improve-productivity/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use columns.&lt;/strong&gt; I’m a full-stack guy so I typically have to deal with writing server-side code as well as front-end code at the same time. I split up backend and front end files into separate columns in the editor. In Sublime this can be achieved by going to View -&amp;gt; Layout -&amp;gt; Then selecting the amount of columns you desire. I typically use two, one side for front-end, one side for backend.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use a different themes.&lt;/strong&gt; I prefer Spacegray. &lt;a href=&quot;https://github.com/kkga/spacegray/&quot;&gt;https://github.com/kkga/spacegray/&lt;/a&gt; Take a look at this for more ideas: &lt;a href=&quot;https://scotch.io/bar-talk/the-best-sublime-text-3-themes-of-2014&quot;&gt;https://scotch.io/bar-talk/the-best-sublime-text-3-themes-of-2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use Source Code Pro&lt;/strong&gt;. In my opinion, it does a bit to enhance readability over the default Courier New: &lt;a href=&quot;https://www.google.com/fonts/specimen/Source+Code+Pro&quot;&gt;https://www.google.com/fonts/specimen/Source+Code+Pro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use plugins.&lt;/strong&gt; Picks one that are relevant to what your needs are, but by far the one that applies to everyone is the Package Control plugin: &lt;a href=&quot;https://packagecontrol.io/browse/popular&quot;&gt;https://packagecontrol.io/browse/popular&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use a project file&lt;/strong&gt; and exclude certain files and folders from search. It also helps you boot directly into your code base.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;*&lt;em&gt;Use Sublime as a terminal command. *&lt;/em&gt;You can boot a project file or just Sublime directly by the ‘subl’ command. Enable it with this: 
&lt;pre&gt;&lt;code data-language=&quot;Bash&quot;&gt;
ln -s &amp;quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&amp;quot; ~/bin/subl&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use a startup script &lt;/strong&gt;to boot a VM if you use one and certainly to load the Sublime project files.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use some helpful keyboard shortcuts. **My most used are:&lt;/strong&gt; **Command + P to search through files in your project. Command + Shift + ] to go to the tab to the right. Command + Shift + [ to go to the tab to the left. Check out the full list: &lt;a href=&quot;http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html&quot;&gt;http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use Multi line select&lt;/strong&gt;. Hold the Alt key and then drag your mouse up and across the lines you want to edit.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  Leave me a comment with some more ideas based on your experience with your preferred editor.
&lt;/div&gt;
</description>
        <pubDate>Sun, 08 Mar 2015 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/sublime-text-workflow-patterns-and-tricks/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/sublime-text-workflow-patterns-and-tricks/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Untested Claims in Software Development</title>
        <description>&lt;p&gt;When I became a developer professionally, I was nervous that I would be unable to keep up with conversations with other developers. The first time I walked into a developer conference I sincerely expected to be of a mindset that wasn&amp;#8217;t scientifically and mathematically rigorous enough. You see I came from a background more steeped in Liberal Arts and other rather soft studies. It wasn&amp;#8217;t until talking with other developers for a while that my opinion of my own prospects began to change. Indeed, I was impressed by how brilliant many of the programmers I talked to were, but I was equally struck by how utterly opinionated I found the milieu of the software development world to be. Things weren&amp;#8217;t black and white &amp;#8212; there weren&amp;#8217;t simply just hard truths and blatant lies. Many assertions made weren&amp;#8217;t even corroborated by any experiment or formal proof. I expected to hear more conversations like this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This algorithm is of O(n) time complexity&lt;/p&gt;

&lt;p&gt;This code will use X bits of memory&lt;/p&gt;

&lt;p&gt;Y amount of power will be consumed on this embedded systems application over Z units of time&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Instead what I heard were conversations that were more like this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;X text editor will make you a better programmer&lt;/p&gt;

&lt;p&gt;Y coding style is the best way to write code&lt;/p&gt;

&lt;p&gt;Z is the best language&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I don&amp;#8217;t mean to indict developers and the community at large. Software is far more subjective than it is objective, despite the mathematical underpinnings of computer science. After all, we call it &amp;#8220;writing&amp;#8221; code for a reason. Moreover, I don&amp;#8217;t mean to cast all conversations in a bad light. I did hear and still often do hear talks that are like the first set of quotes rather than the second.&lt;/p&gt;

&lt;p&gt;However, what I do intend to indict is the zeal by which we can make claims that really aren&amp;#8217;t tested or proven. Debates are certainly good, and we should suss out the truth in everything we can in the world. But when we have conversations like the first set of quotes above, all we can do is talk &lt;em&gt;at&lt;/em&gt; each other and exchange anecdotes, either vociferously or cordially. While I&amp;#8217;m pretty convinced that Vim is a really fantastic text editor and not having to use a mouse as frequently makes &lt;strong&gt;me&lt;/strong&gt; a &amp;#8220;better&amp;#8221; developer, I can&amp;#8217;t claim that would be true for &lt;strong&gt;all&lt;/strong&gt; developers. After all, some people love Emacs! Perhaps a formal study could prove my claim one way or another, but in the end, by making unproven claims we are taking a little of the science away from the study of computer science.&lt;/p&gt;

&lt;p&gt;What should we do then? How can we resolve a problem that seems so intractable? Well for one, I think we need to be honest with ourselves about where our claims are grounded. Have they been proven, in the same way that merge sort&amp;#8217;s time complexity has or, are they merely beliefs we have gathered over our years of professional experience?&lt;/p&gt;

&lt;p&gt;Second, I think more empirical studies are in order. There have already been quite a few, such as one regarding &lt;a href=&quot;http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&amp;amp;arnumber=5521745&quot;&gt; if camelCase or underscores&lt;/a&gt; are easier to read. A lot of claims can be formally tested and terms can be operationally defined, despite what a tall order that may seem. We can apply some rigor to the word &amp;#8220;better&amp;#8221; when we talk about what makes for a better developer. We can truly settle debates about if Agile development is the best way to go. And, we can have more assurance that our design patterns will truly be productive and not just a continuation in a long line of uncontrolled experiments. While the new year is still fresh, my wish is to improve not just our skills and our codebases, but our mindset about software development. At the very least, maybe we can all agree on that!&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/untested-claims-in-software-development/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/untested-claims-in-software-development/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Software Design: 5 Things I Have Learned So Far</title>
        <description>&lt;p&gt;Over the last few years of developing software professionally I&amp;#8217;ve gathered up a few insights based on my experiences. These don&amp;#8217;t apply to every kind of project or company, but in general I hope they are helpful.&lt;/p&gt;

&lt;h1&gt;1.&lt;/h1&gt;

&lt;address&gt;
  &lt;em&gt;When dealing with user accounts, make users part of an organization.&lt;/em&gt;
&lt;/address&gt;

&lt;p&gt;It&amp;#8217;s easy to assume that just an individual user is going to be registered for the usage of your application and that will be that. It&amp;#8217;s trivial to implement &amp;#8212; most frameworks have a built-in or third-party authentication plugin for handling what ends up being individual user registration. This is great to solve the problem at hand for most apps, however as your application grows, it&amp;#8217;s very possible that you will want to include multiple users along with associated permissions. There&amp;#8217;s little harm in having an organization as a first-class citizen and users as second.&lt;/p&gt;

&lt;h1&gt;2.&lt;/h1&gt;

&lt;address class=&quot;p1&quot;&gt;
  &lt;em&gt;&lt;span class=&quot;s1&quot;&gt;Any data integrity or security checks you do in the client must also be done on the backend.&lt;/span&gt;&lt;/em&gt;
&lt;/address&gt;

&lt;p class=&quot;p1&quot;&gt;
  This seems very obvious at first, but if you are going to limit functionality on a user level basis, or as per having a login session token, then limits placed on the client API calls must also be placed server-side as well.
&lt;/p&gt;

&lt;h1&gt;3.&lt;/h1&gt;

&lt;address class=&quot;p1&quot;&gt;
  &lt;em&gt;&lt;span class=&quot;s1&quot;&gt;Know what can be cached and what can&amp;#8217;t.&lt;/span&gt;&lt;/em&gt;
&lt;/address&gt;

&lt;p class=&quot;p1&quot;&gt;
  If your app is making expensive calls and manipulations on data from your RDB or even NoSQL database, a caching strategy should be used.  Caching though is a hard solution though, to what is superficially an easy problem &amp;#8212; too many database calls. To implement caching effectively you must also implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_invalidation&quot;&gt;cache invalidation&lt;/a&gt; properly, and as the saying goes, cache invalidation is one of the hardest problems in computer science. A simple strategy for some apps is to cache transient, yet hard to compute data, and refresh it at a fixed interval. This won&amp;#8217;t work for every application so it&amp;#8217;s important to consider your own unique design requirements.
&lt;/p&gt;

&lt;h1&gt;4.&lt;/h1&gt;

&lt;address class=&quot;p1&quot;&gt;
  &lt;em&gt;&lt;span class=&quot;s1&quot;&gt;Use deleted codes for entries instead of deleting rows.&lt;/span&gt;&lt;/em&gt;
&lt;/address&gt;

&lt;p class=&quot;p1&quot;&gt;
  Quite often, a user will erroneously delete some of their data and they will want it back. Instead of doing DELETE FROM &lt;em&gt;table_name &lt;/em&gt;WHERE &lt;em&gt;some_column&lt;/em&gt;=&lt;em&gt;some_value&lt;/em&gt;; it can be better to simply UPDATE a table with a column that is called something like status_code. When you are retrieving rows from your RDB, simply check for rows with an active status code. This also creates a nice design pattern that lets you set all sorts of different properties of your data, other than just DELETED.
&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt;
  I should note, this insight does not apply to all applications &amp;#8212; if you are dealing with very sensitive consumer data and are dealing with HIPAA, PCI, or any of the myriad regulations out there, then this may not be the best idea. Also, if you are dealing with a high volume of relational data, you may not want to preserve everything that is no longer needed. Notwithstanding this, there are many good reasons to simply UPDATE a status_code column, as opposed to calling a SQL DELETE command.
&lt;/p&gt;

&lt;h1&gt;5.&lt;/h1&gt;

&lt;address class=&quot;p1&quot;&gt;
  &lt;em&gt;&lt;span class=&quot;s1&quot;&gt;Languages and frameworks can be productivity enhancements, but they don&amp;#8217;t solve the hard problems for you.&lt;/span&gt;&lt;/em&gt;
&lt;/address&gt;

&lt;p class=&quot;p1&quot;&gt;
  Every time the sun comes up it seems a new framework rises with it. MVC frameworks can solve many of the basic problems of application development, and certainly they should always used. The biggest problems though in designing software aren&amp;#8217;t going to be addressed by a new framework or a fresh new language. Quite often actually, not using a tried and trusted technology stack can actually introduce more problems. The biggest challenges you will face will be in actually creating an application to fulfill your customer&amp;#8217;s needs. Sure scaling will be an issue, but that&amp;#8217;s one of those good problems to have &amp;#8212; it means you&amp;#8217;re solving a lot of people&amp;#8217;s problems. For the meantime, use something that works, even if it isn&amp;#8217;t that sexy.
&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Nov 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/software-design-5-things-i-have-learned-so-far/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/software-design-5-things-i-have-learned-so-far/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Software and Hardware in IoT</title>
        <description>&lt;p&gt;I was sitting down with a friend recently, talking over a late lunch one afternoon. He&amp;#8217;s a hardware guy, I&amp;#8217;m a software guy. He was telling me about a trend he noticed recently: people don&amp;#8217;t want to pay for software. I thought that maybe he&amp;#8217;s saying that out of ego, or maybe he&amp;#8217;s just saying that because there&amp;#8217;s a million apps on the market and there&amp;#8217;s always value in rarity. He didn&amp;#8217;t believe that though, so ellaborated. He said, &amp;#8220;People can&amp;#8217;t spend 99 cents on an app. They&amp;#8217;ll do anything it takes to use software but not pay for it &amp;#8212; stealing licenses, torrenting, you name it. But show them a cool device for a good price that solves their problems, they&amp;#8217;ll pay good money for it.&amp;#8221;&lt;/p&gt;

&lt;p&gt;I mulled that over and analyzed my own life. I&amp;#8217;ve waited out almost indefitenly on signing up for premium services on software I use every day, just to stay in the semi-working freemium state I was used to for so long. Why is that? How come I couldn&amp;#8217;t bring myself to pay for something that I use and would use even more every day?&lt;/p&gt;

&lt;p&gt;It seems tangibility, like rarity, matters a lot to value. You&amp;#8217;ll buy a crappy beer for 4 bucks at a bar, but if you bought a crappy app for the same price you could be enraged. So enraged maybe you might even leave a review on the app store or send an email to customer support. Would you do the same on the bar&amp;#8217;s Yelp page?&lt;/p&gt;

&lt;p&gt;There&amp;#8217;s something about the physical that is spellbinding in the most visceral way, almost more so than anything software can do. Yet we aren&amp;#8217;t talking about beer, or food, or clothes though. We are talking about digital devices. A beautiful and amazingly functional piece of hardware is a tangible thing you can pick up and hold, but what is the value of it to your life? What is your interaction with it that serves a function for you?&lt;/p&gt;

&lt;p&gt;The truth is, you find the value in the software. When you interact with a digital device it&amp;#8217;s with an interface powered by software. When the digital device alerts you to something it&amp;#8217;s the software that does it. When you control it to do a specific action for you, it&amp;#8217;s through the software. This is not all to say the hardware or the engineers are unimportant, quite the contrary. It&amp;#8217;s simply that software is what gives the hardware purpose.&lt;/p&gt;

&lt;p&gt;This may all seem elementary and like a rehased argument from the days of yore, but it&amp;#8217;s important to remember in the emerging world of the Internet of Things. There&amp;#8217;s a lot of focus on how hardware startups are taking an ever-increasing amount of VC investments, and how it&amp;#8217;s the hardware in the form of sensors and actuators that are defining the Internet of Things. That&amp;#8217;s fundamentally wrong, it&amp;#8217;s the software, and of course the hardware, that are shaping the industry. With more and more sensors in the world, there will need to be better and better software. Software that helps you make decisions from the hardware in your life, and let&amp;#8217;s you control devices that have meaning to you. In other words, we need as good of software for IoT as hardware. It&amp;#8217;s not all about simply seeing your coffee maker or fridge on the internet. It&amp;#8217;s about the devices you have enhancing your life through the data and control they provide you, all via: software!&lt;/p&gt;
</description>
        <pubDate>Wed, 24 Sep 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/software-and-hardware-in-iot/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/software-and-hardware-in-iot/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Docker and the Future of Software</title>
        <description>&lt;p&gt;Recently I started taking a look at &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; which aims to be the future of shipping software. I was skeptical at first but after watching several videos (&lt;a href=&quot;https://www.youtube.com/watch?v=Q5POuMHxW-0&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=pts6F00GFuU&quot;&gt;2&lt;/a&gt;) I was blown away by the possibilities and what this means for the future of software. The power of Docker is the ultimate abstraction from the underlying operating system.&lt;/p&gt;

&lt;p&gt;We have been stuck in a model of tying all of our software dependencies and our applications themselves to the very same file system and package directories that our operating systems use. Keeping track of our development and production box&amp;#8217;s installations of our app&amp;#8217;s dependencies is not the kind of productive work we should be doing as developers. We should be focusing on our applications!&lt;/p&gt;

&lt;p&gt;Realizing this observation about Docker struck me. I think we will look at the world before Docker much in the way we look at the world of literature before the printing press &amp;#8212; everything was done by hand with far too much energy and subjected our work to a great deal of human error.&lt;/p&gt;

&lt;p&gt;The other metaphor that strikes me is the one proclaimed by the Docker community, and is at the very core of its philosophy &amp;#8212; that is &lt;em&gt;containerization&lt;/em&gt;. With Docker, we realize that what we should be doing is specifying our app&amp;#8217;s entire software ecosystem as a container, and not as a series of installations we need to do directly on the server that will be running our code. We should feel confident knowing that our local development boxes and every single on of our production boxes as well are using an identical setup, just as a civil engineer feels confident that her CAD mockups and physical simulation software maps exactly to the real world or a ship captain knows that the company&amp;#8217;s goods will be handled identically on every ship and every port.&lt;/p&gt;

&lt;p&gt;As the world&amp;#8217;s computing needs grow, especially with the coming of IoT and the incredible volume of data that will arise from all of our sensors, we need scalable ways of keeping our software dependencies and applications in controlled and contained states. Docker is the best solution I see.&lt;/p&gt;

&lt;h3&gt;My practical Docker example:&lt;/h3&gt;

&lt;p&gt;I was working on a quick side project and took the chance to create a Dockerfile for a Python 3 Flask App that uses uWSGI and Nginx. &lt;a href=&quot;https://github.com/ryanmcdermott/docker-flask&quot;&gt;Check it out on my GitHub project&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Aug 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/docker-and-the-future-of-software/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/docker-and-the-future-of-software/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>HomeKit&amp;#8217;s Breath of Life</title>
        <description>&lt;h4&gt;What is IoT&amp;#8217;s Current State?&lt;/h4&gt;

&lt;p&gt;Whenever I hang out with relatives, or friends that are unfamiliar to the tech scene, I always bring up the emerging trend of Internet of Things. As I talk about common household and industrial devices equipped with sensors that communicate with each other and connect to the web, I notice their faces show a lot of intrigue. They tell me they see the value in a world with this kind of technology. When I ask them though if they own anything like what I am mentioning they say they don&amp;#8217;t.&lt;/p&gt;

&lt;h4&gt;So why is that?&lt;/h4&gt;

&lt;p&gt;How come we are making so many advances in these technologies on a hardware level, yet we haven&amp;#8217;t seen a large adoption of IoT? Perhaps maybe it&amp;#8217;s because we haven&amp;#8217;t made enough advances on the software side.&lt;/p&gt;

&lt;p&gt;With Apple&amp;#8217;s announcement of HomeKit this week that just &lt;a href=&quot;https://www.youtube.com/watch?v=FggJeMwbLjg&quot;&gt;might be changing&lt;/a&gt;. HomeKit aims to fix the data silo issue, which is perhaps the biggest problem with IoT achieving more widespread adoption. Popular devices like Nest, Fitbit, SmartThings, and the many others all have their own apps and dashboards.What&amp;#8217;s more, many establish their own protocol to communicate to other devices. With MQTT and Z-Wave gaining a lot in popularity some of these protocol issues are being solved organically, but yet there&amp;#8217;s no cloud solution to connect these devices together. HomeKit just might be the best bet to solve this problem.&lt;/p&gt;

&lt;h4&gt;Why Apple&amp;#8217;s HomeKit over other solutions?&lt;/h4&gt;

&lt;p&gt;Well doubtlessly there are many other great solutions such as up-and-coming startups like &lt;a href=&quot;http://2lemetry.com/&quot;&gt;2lemetry&lt;/a&gt;. The difference though between these startups and Apple is that Apple has the cachet to not only excite many on-the-fence consumers about IoT, but they have the power to work with the many IoT device makers to agree on a standard interface and cloud solution for their products instead of simply consigning all functionality to their own home-brewed solutions.&lt;/p&gt;

&lt;h4&gt;What is beyond HomeKit?&lt;/h4&gt;

&lt;p&gt;Clearly, we don&amp;#8217;t just need a central place to connect all of our devices in order for us to actuate them with Siri. That is a undoubtedly a nice thing, but our devices need to be truly smart. Wouldn&amp;#8217;t it be better if your door lock, garage, and lights to learn when your sleep patterns were than for you having to command it through Siri? Moreover, wouldn&amp;#8217;t it also be nice if they synced with your Google Calendar and learned when you were on vacation? Or even more intelligently, what if your moisture sensor in your attic went off and knew to schedule a repairman to come by for you? There are limitless possibilities when AI is applied to this. The first step though is having a cloud solution to work with all of the connected devices that we have or will end up having. If that solution is not HomeKit, let&amp;#8217;s hope it&amp;#8217;s something else that comes just as soon!&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/apple-homekit-iot/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/apple-homekit-iot/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Heartbleed and the Heart of IoT</title>
        <description>&lt;p&gt;Every so often there are events that change public opinion about a facet of our lives. Whether its recalls on the red dye in our food, revelations about carcinogens in our environment, or disastrous warnings of climate change, we are occasionally pummeled by life-changing news. I think &lt;a href=&quot;http://www.nytimes.com/2014/04/10/technology/users-stark-reminder-as-web-grows-it-grows-less-secure.html?hp&amp;amp;_r=0&quot;&gt;Heartbleed&lt;/a&gt;  is one of these news events where public opinion might change permanently.&lt;/p&gt;

&lt;p&gt;This comes on the heels of the Snowden revelations of the past year, and is a rather nasty culmination of security news for the tech world. At a time when our world is becoming connected in fundamentally transformative ways for the human race, we are being impeded by purely cynical corruption from our government on the one hand and bad security software on the other.&lt;/p&gt;

&lt;p&gt;The future of our current web and the future of our web of tomorrow depend squarely on us having faith in the systems we have created. The Internet has brought more prosperity in terms of actual wealth and knowledge than any single invention in the span of human history &amp;#8212; more so than even our writing systems and printing presses.&lt;/p&gt;

&lt;p&gt;We have connected all of our computers, and digitized so much of the world’s information. All of that is accessible now by devices in our own pockets. A child in the poorest country in the world with a computer and an internet connection has as much access to knowledge as the richest person in the world did just 40 years ago. That is progress.&lt;/p&gt;

&lt;p&gt;IoT is the next big leap in progress humanity will make. By connecting all of the world’s devices we will bring phenomenal potential for instantaneous knowledge of our environment, incredibly improved data about our world, and the power to have machines make so many of the mundane decisions about our lives. The only thing that should stand in our way are resources, not our distrust of the very devices that will improve our lives so immensely. As bad as these security revelations are, we shouldn’t despair. Progress will be made. Let us be optimistic, and let us move forward, even if our heart bleeds along the way.&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Apr 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/heartbleed-iot/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/heartbleed-iot/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Towards a Triggering Language</title>
        <description>&lt;p&gt;Let us fast forward 50 years. We are living in a world of connected devices. Everything around us responds intelligently to our needs, wants, and emotions. We awake on a weekend morning:&lt;/p&gt;

&lt;p&gt;The lights turn on slowly as your bed detects you slowly rising after your sleep. Your coffee pot fills with water and heats itself to a simmer.  You saunter over into your kitchen. Your fridge recommends foods based on readings from your latest medical checkup. As you begin to eat, music comes on mezzo forte through your stereo. It best matches your current mood based on natural language processing of yesterday&amp;#8217;s text messages. You walk into your living room and look for your keys. They ring to alert you where they are, knowing already that you have a scheduled Frisbee meetup at the local park. Your car turns itself on as you walk outside. As you get in, it begins to drive itself. You read the latest news on your phone and as you get to a stop light, there&amp;#8217;s an explosion of in the distance. You look on, with a confounded expression. Emergency personnel are alerted to the area based on decibel readers installed on all public land in your municipality. Must have been a gas line break, you assume. You make it to the Frisbee field and your car knows exactly the optimal place to park. You step outside, and enjoy the day, unaware of the bytes whirling around you that are as much a part of your day as the people and things you love.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s go back in time now, to the present moment. When we look at this future world, one thing is clear: there&amp;#8217;s truly intelligence to our &amp;#8220;smart&amp;#8221; devices. Devices seem to be communicating with one another. How though? How is it that the lights know when to turn on? How does the coffee pot know to start? How is it that anything knows what to do, for, to, and with another device or set of devices? We can certainly reduce this down to something very simple: a series of &amp;#8220;if this, then that&amp;#8221; cases.&lt;/p&gt;

&lt;p&gt;This is an attractive thought. After all, we can think of this, along with many other complex phenomena in life, as simply input and output, or cause and effect. If [morning], then [lights_on]. If [woken_up], then [coffee_starts]. This simplistic way of looking at the problem. Is this something though that we can actually use technically? Is our world really going to be a series of if and then statements, or will we live with a richer set of conditionals?&lt;/p&gt;

&lt;p&gt;I would bet my bucks on the latter. The world is messy. Why wouldn&amp;#8217;t our devices conform to that? Decibel readers in a city wouldn&amp;#8217;t simply trigger emergency teams if they detect a higher decibel level than the set threshold. Proximity to crime, density of population in the area, and history of explosions are all things that would be factored in. Not to mention, all other relevant data.&lt;/p&gt;

&lt;p&gt;Simple if then, and even else, cases don&amp;#8217;t work well enough to capture these kinds of conditionals in the real world. What we need is a triggering language for M2M communication. One that can handle loops, comparisons, routing data to other devices, sending actions, executing system calls, negation, and normal if, elseif, else cases. A primitive example of such a language could look something like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if ([dev] [reports] X or [system call returns] Y){
    to device, device, device do action with [data];
}

unless ([dev] [reports] Y) {
    to device do action;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a very basic example alone but it handles a much wider array of cases. Let&amp;#8217;s look at what such a clause of this language would look like with a real world example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if ([moisture_detector] [report] == &amp;quot;water&amp;quot; or [syscall: time_to_end] == true){
    to sprinkler1, sprinkler2, sprinkler3 do [turn_off] with [data: slow];
}

unless ([moisture_detector] [reports] &amp;quot;water&amp;quot;) {
    to sprinkler1, sprinkler2, sprinkler3 do [water_grass];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are many advantages to this approach. You can do analysis with data returned from the device and compare it to report codes. Furthermore, you can specify loops of actions, as well as multiple routes for data. Another advantage is that being able to call system functions and act on their returned data, whether the function is on the device or a server, allows you more intelligent processing, reporting, and actuating on any device. Simple if then cases won&amp;#8217;t suffice with large sensor and actuator systems. Imagine the spaghetti code of conditionals! These communication fragments are the currency of future AI systems for these sensor networks. Conditionals and triggers change as AI dictates. Imagine what the AI system would do when it finds out your water bill is too high! That &lt;em&gt;unless&lt;/em&gt; case would include an &lt;em&gt;and&lt;/em&gt; clause that makes a comparison with your budget. There&amp;#8217;s an infinite amount of things that are possible with this kind of approach, and I think it&amp;#8217;s one worth exploring.&lt;/p&gt;

&lt;p&gt;Stay tuned for further blog posts as I continue on this endeavor, one I call &lt;strong&gt;MTL: Machine Triggering Language&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Mar 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/towards-a-triggering-language/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/towards-a-triggering-language/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Strong IoT and Strong AI</title>
        <description>&lt;p&gt;Two of the biggest things that are happening technologically for humanity are in connecting all of the things we make to the world and understanding how we as humans connect with it. We are going from living in a world where our connections to it require human interaction to a world where our connections will connect themselves for us. Simply said, what matters now are device connections and neural connections.&lt;/p&gt;

&lt;p&gt;These things are the Internet of Things and Artificial Intelligence, respectively. Both domains aren&amp;#8217;t new by any means. AI has the reputation of being ostracized in academia after decades of failures in neural networking and learning algorithms to achieve the dreams of the domain. However, now with many&lt;a href=&quot;http://www.youtube.com/watch?v=AyzOUbkUf3M&quot;&gt; new theories and technologies&lt;/a&gt;, as well as startup acquisitions, the dream of AI is very much alive in academia and the culture at large. Similarly, IoT has gone from being a science fiction plot to becoming a much more achievable reality. With DIY kits like Raspberry Pi, along with every iteration of Arduino and other microcontrollers, there&amp;#8217;s a sense now that we can really start to connect the world in profound ways.&lt;/p&gt;

&lt;p&gt;However, in spite of all of this success, both domains seem to be increasing horizontally as opposed to vertically. There&amp;#8217;s a plethora of &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_artificial_intelligence_projects&quot;&gt;&amp;#8220;AI&amp;#8221; technologies&lt;/a&gt;. Everything from the classic Deep Blue of the 90s, to the Google driverless car is considered AI. Certainly there is intelligence behind these innovations, and they are truly stunning, but we must ask: are these technologies just automating away a problem or are they getting us closer to truly understanding how understanding works? In other words, do these technologies learn in a way that is outside of their scope?&lt;/p&gt;

&lt;p&gt;It seems that when we talk about AI  nowadays, we are really just talking about automation. Is it really intelligent if a program knows how to &lt;a href=&quot;http://singularityhub.com/2011/09/19/ai-journalist-writes-sports-and-now-everything-else-statsheet-raises-4m-changes-name-and-focus/&quot;&gt;be a sports writer?&lt;/a&gt; What is such a machine or program doing beyond its own programmed abilities? Learning is the basis of intelligence, processing is secondary. Yet, it&amp;#8217;s processing, based on very structured learning, that we seem to think of as the truly intelligent act.&lt;/p&gt;

&lt;p&gt;Our intelligence is defined by our abilities to learn beyond the scope we are born with. Imagine when Neil Armstrong&amp;#8217;s mother held him for the first time. Would it have even been in her imagination that Neil would ever step foot on another celestial body? When you look at a child, their innate scope of the world is incredibly small, but when you look at an a&lt;em&gt;rtificially intelligent&lt;/em&gt; program the scope is immediately laid out for you. It&amp;#8217;s not as if Neil Armstrong was born with a file that said he would become an astronaut. However, every a&lt;em&gt;rtificially intelligent&lt;/em&gt; system I&amp;#8217;ve seen has been explained to me in terms of precisely what it can ever accomplish. No human being is born with such a fate.&lt;/p&gt;

&lt;p&gt;With respect to the AI world, the IoT market is similarly stratified horizontally. There are amazing sensors and actuators made by a wide array of &lt;a href=&quot;http://postscapes.com/companies/&quot;&gt;impressive companies&lt;/a&gt; but it feels as if every IoT solution is just a &lt;em&gt;smart device &lt;/em&gt;that accomplishes one task very well, just like AI. What would it mean then to have vertical AI, often referred to as &lt;a href=&quot;http://en.wikipedia.org/wiki/Artificial_general_intelligence&quot;&gt;strong AI&lt;/a&gt;? It would simply be that we develop machines and programs that can learn, process, and act beyond their initial programming and can interact with the world in a novel way not imagined by its developers. In a way, it would do something that a human being could do that takes a significant amount of intelligence.&lt;/p&gt;

&lt;p&gt;What then would vertical IoT, or strong IoT look like? It &lt;strong&gt;wouldn&amp;#8217;t&lt;/strong&gt; simply be when there are a lot of sensors and actuators on the primary objects we use. It would be when there&amp;#8217;s actually &amp;#8220;internet&amp;#8221; to the Internet of Things. We will have come a long way when we stop having silos of networks and web apps for a particular brand&amp;#8217;s line of IoT and when there&amp;#8217;s an open interaction between all devices. Security considerations of course must be addressed but when we have open protocols and popular solutions for connecting and interacting with IoT devices, as if they were social networks, then we will be much further to &lt;em&gt;strong IoT&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What happens then when we have achieved both strong AI and strong IoT? Well, some very exciting things will occur. We will truly have asymptotic changes in our society when artificially intelligent systems understand the physical world and direct it in productive ways that are beyond the power of an individual human being or groups of humans. When a system knows that something is going wrong in the environment based on some sensory data and its ability to learn, then we have transformative systems that go far beyond the reach of simple robotics. We will have intelligent systems that will know when a wild fire is happening and put it out, that will be able to organize your schedule after reading your emails, and that will be able to empower cities to be able to set up quick responses to emergency situations.&lt;/p&gt;

&lt;p&gt;The IoT world and the AI world are converging. When we imagine ourselves in a world dominated by an Internet of Things, most of us actually imagine things that have a network with some intelligence. Mere sensors and actuators are great and mere automative AI programs are useful, but the two together are as transformative as the Industrial Revolution and the PC Revolution were. Who knows how far away this world will be but there will be plenty of room for new startups and even more room for imagination!&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Mar 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/strong-iot-and-strong-ai/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/strong-iot-and-strong-ai/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>The Future of The Internet of Things</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://ryansworks.com/wp-content/uploads/2014/02/Blank-Venn-Diagram-Plain.jpeg&quot;&gt;&lt;img class=&quot;alignnone size-large wp-image-211&quot; src=&quot;http://ryansworks.com/wp-content/uploads/2014/02/Blank-Venn-Diagram-Plain-1024x791.jpeg&quot; alt=&quot;Blank Venn Diagram - Plain&quot; width=&quot;1024&quot; height=&quot;791&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Feb 2014 00:00:00 +0000</pubDate>
        <link>http://www.ryansworks.com/the-future-internet-of-things/</link>
        <guid isPermaLink="true">http://www.ryansworks.com/the-future-internet-of-things/</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
  </channel>
</rss>
